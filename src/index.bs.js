// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Id from "rescript/lib/es6/belt_Id.js";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Belt_Map from "rescript/lib/es6/belt_Map.js";
import * as Belt_Set from "rescript/lib/es6/belt_Set.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Range from "rescript/lib/es6/belt_Range.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Webapi__Dom__Element from "rescript-webapi/src/Webapi/Dom/Webapi__Dom__Element.bs.js";

function cmp(param, param$1) {
  var rowB = param$1[0];
  var rowA = param[0];
  if (Caml_obj.caml_equal(rowA, rowB)) {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  } else {
    return Caml_obj.caml_compare(rowA, rowB);
  }
}

var CellCmp = Belt_Id.MakeComparable({
      cmp: cmp
    });

var flaggedCellsSet = {
  contents: Belt_Set.make(CellCmp)
};

var revealedCellsSet = {
  contents: Belt_Set.make(CellCmp)
};

var cellsDomMap = {
  contents: Belt_Map.make(CellCmp)
};

var mineField = document.getElementById("minefield");

var restart = document.getElementById("restart");

var congrats = document.getElementById("congrats");

var congrats$1 = (congrats == null) ? undefined : Caml_option.some(congrats);

var loh = document.getElementById("loh");

var loh$1 = (loh == null) ? undefined : Caml_option.some(loh);

function toggleElement(element, displayValue) {
  if (element === undefined) {
    return ;
  }
  var htmlElement = Webapi__Dom__Element.asHtmlElement(Caml_option.valFromOption(element));
  if (htmlElement === undefined) {
    return ;
  }
  var __x = Caml_option.valFromOption(htmlElement).style;
  __x.setProperty("display", displayValue, "");
  
}

function neighbourCells(param) {
  var col = param[1];
  var row = param[0];
  var neighbours = [
    [
      row,
      col + 1 | 0
    ],
    [
      row,
      col - 1 | 0
    ],
    [
      row + 1 | 0,
      col + 1 | 0
    ],
    [
      row + 1 | 0,
      col - 1 | 0
    ],
    [
      row - 1 | 0,
      col + 1 | 0
    ],
    [
      row - 1 | 0,
      col - 1 | 0
    ],
    [
      row + 1 | 0,
      col
    ],
    [
      row - 1 | 0,
      col
    ]
  ];
  var filter = function (param) {
    var col = param[1];
    var row = param[0];
    return !(row < 0 || col < 0 || row > 8 || col > 8);
  };
  return neighbours.filter(filter);
}

function applyStyling(param) {
  if (mineField == null) {
    return ;
  }
  var htmlMineField = Webapi__Dom__Element.asHtmlElement(mineField);
  if (htmlMineField === undefined) {
    return ;
  }
  var htmlMineField$1 = Caml_option.valFromOption(htmlMineField);
  var __x = htmlMineField$1.style;
  __x.setProperty("width", String(270) + "px", "");
  var __x$1 = htmlMineField$1.style;
  __x$1.setProperty("height", String(270) + "px", "");
  
}

function showBombs(bombsMap, cell) {
  var domCell = Belt_Map.get(cellsDomMap.contents, cell);
  if (domCell !== undefined) {
    var htmlCell = Webapi__Dom__Element.asHtmlElement(Caml_option.valFromOption(domCell));
    if (htmlCell !== undefined) {
      toggleElement(loh$1, "block");
      var __x = Caml_option.valFromOption(htmlCell).style;
      __x.setProperty("background-color", "red", "");
    }
    
  }
  var __x$1 = Belt_Map.reduce(bombsMap, [], (function (cells, cell, value) {
          if (value !== 0) {
            return cells;
          } else {
            return Belt_Array.concat(cells, [cell]);
          }
        }));
  return Belt_Array.forEach(__x$1, (function (cell) {
                var domCell = Belt_Map.get(cellsDomMap.contents, cell);
                if (domCell === undefined) {
                  return ;
                }
                var __x = Caml_option.valFromOption(domCell);
                __x.textContent = "ðŸ’£";
                
              }));
}

function revealCell(bombsMap, cell, cellDom) {
  var setBtnStyle = function (value, color) {
    cellDom.textContent = value;
    var htmlCell = Webapi__Dom__Element.asHtmlElement(cellDom);
    if (htmlCell === undefined) {
      return ;
    }
    var __x = Caml_option.valFromOption(htmlCell).style;
    __x.setProperty("color", color, "");
    
  };
  var value = Belt_Map.get(bombsMap, cell);
  if (value !== undefined) {
    switch (value) {
      case 0 :
          return showBombs(bombsMap, cell);
      case 1 :
          return setBtnStyle("1", "blue");
      case 2 :
          return setBtnStyle("2", "green");
      default:
        return setBtnStyle(String(value), "red");
    }
  } else {
    var cellHtml = Webapi__Dom__Element.asHtmlElement(cellDom);
    if (cellHtml === undefined) {
      return ;
    }
    var __x = Caml_option.valFromOption(cellHtml).style;
    __x.setProperty("background-color", "grey", "");
    return ;
  }
}

function revealCells(bombsMap, cell) {
  var reducer = function (cell) {
    if (Belt_Set.has(revealedCellsSet.contents, cell)) {
      return ;
    }
    var cellDom = Belt_Map.get(cellsDomMap.contents, cell);
    if (cellDom !== undefined) {
      revealCell(bombsMap, cell, Caml_option.valFromOption(cellDom));
    }
    revealedCellsSet.contents = Belt_Set.add(revealedCellsSet.contents, cell);
    return revealCells(bombsMap, cell);
  };
  if (Belt_Map.has(bombsMap, cell)) {
    return ;
  } else {
    return Belt_Array.forEach(neighbourCells(cell), reducer);
  }
}

function toggleFlag(cell, domCell) {
  if (Belt_Set.has(flaggedCellsSet.contents, cell)) {
    flaggedCellsSet.contents = Belt_Set.remove(flaggedCellsSet.contents, cell);
    domCell.textContent = "";
  } else {
    flaggedCellsSet.contents = Belt_Set.add(flaggedCellsSet.contents, cell);
    domCell.textContent = "ðŸš©";
  }
  
}

function createButton(bombsMap, cell) {
  var cellDom = document.createElement("button");
  cellsDomMap.contents = Belt_Map.set(cellsDomMap.contents, cell, cellDom);
  cellDom.addEventListener("contextmenu", (function ($$event) {
          toggleFlag(cell, cellDom);
          $$event.preventDefault();
          var bombsCells = Belt_Map.reduce(bombsMap, [], (function (arr, k, v) {
                  if (v !== 0) {
                    return arr;
                  } else {
                    return Belt_Array.concat(arr, [k]);
                  }
                }));
          var match = Belt_Set.cmp(flaggedCellsSet.contents, Belt_Set.fromArray(bombsCells, CellCmp));
          if (match !== 0) {
            return ;
          } else {
            return toggleElement(congrats$1, "block");
          }
        }));
  cellDom.addEventListener("click", (function (param) {
          revealCell(bombsMap, cell, cellDom);
          return revealCells(bombsMap, cell);
        }));
  var htmlCell = Webapi__Dom__Element.asHtmlElement(cellDom);
  if (htmlCell !== undefined) {
    var htmlCell$1 = Caml_option.valFromOption(htmlCell);
    var __x = htmlCell$1.style;
    __x.setProperty("float", "left", "");
    var __x$1 = htmlCell$1.style;
    __x$1.setProperty("width", String(30) + "px", "");
    var __x$2 = htmlCell$1.style;
    __x$2.setProperty("height", String(30) + "px", "");
  }
  return cellDom;
}

function generateBombsMap(bombs) {
  var bombsMap = Belt_Map.make(CellCmp);
  var increaseDanger = function (map, cell) {
    var value = Belt_Map.get(map, cell);
    if (value !== undefined) {
      if (value === 0) {
        return map;
      } else {
        return Belt_Map.set(map, cell, value + 1 | 0);
      }
    } else {
      return Belt_Map.set(map, cell, 1);
    }
  };
  var reducer = function (map, bombCell) {
    var __x = neighbourCells(bombCell);
    return Belt_Array.reduce(__x, Belt_Map.set(map, bombCell, 0), increaseDanger);
  };
  return Belt_Array.reduce(bombs, bombsMap, reducer);
}

function generateBombs(_gennedBombs, bombsCount) {
  while(true) {
    var gennedBombs = _gennedBombs;
    var genCoordTuple = function (param) {
      return [
              Js_math.random_int(0, 9),
              Js_math.random_int(0, 9)
            ];
    };
    if (gennedBombs !== undefined) {
      var length = gennedBombs.length;
      if (length < bombsCount) {
        return generateBombs(gennedBombs.concat([genCoordTuple(undefined)]), bombsCount);
      }
      var bombs = gennedBombs.reduce((function (withoutCoopies, param) {
              var row = param[1];
              var col = param[0];
              var match = withoutCoopies.find(function (param) {
                    if (param[1] === row) {
                      return param[0] === col;
                    } else {
                      return false;
                    }
                  });
              if (match !== undefined) {
                return withoutCoopies;
              } else {
                return withoutCoopies.concat([[
                              col,
                              row
                            ]]);
              }
            }), [Caml_array.get(gennedBombs, 0)]);
      if (bombsCount === bombs.length) {
        return bombs;
      } else {
        return generateBombs(bombs, bombsCount);
      }
    }
    _gennedBombs = [genCoordTuple(undefined)];
    continue ;
  };
}

function generateField(param) {
  var bombsMap = generateBombsMap(generateBombs(undefined, 9));
  var reducer = function (colId) {
    return Belt_Range.forEach(0, 8, (function (rowId) {
                  if (mineField == null) {
                    return ;
                  }
                  var btn = createButton(bombsMap, [
                        colId,
                        rowId
                      ]);
                  mineField.appendChild(btn);
                  
                }));
  };
  return Belt_Range.forEach(0, 8, reducer);
}

function startGame(param) {
  applyStyling(undefined);
  return generateField(undefined);
}

applyStyling(undefined);

generateField(undefined);

if (!(restart == null)) {
  restart.addEventListener("click", (function (param) {
          flaggedCellsSet.contents = Belt_Set.make(CellCmp);
          revealedCellsSet.contents = Belt_Set.make(CellCmp);
          cellsDomMap.contents = Belt_Map.make(CellCmp);
          toggleElement(loh$1, "none");
          toggleElement(congrats$1, "none");
          if (mineField == null) {
            return ;
          }
          var __x = Array.prototype.slice.call(mineField.children);
          Belt_Array.map(__x, (function (child) {
                  return mineField.removeChild(child);
                }));
          applyStyling(undefined);
          return generateField(undefined);
        }));
}

var rows = 9;

var cols = 9;

var size = 30;

var mineField$1 = (mineField == null) ? undefined : Caml_option.some(mineField);

var restart$1 = (restart == null) ? undefined : Caml_option.some(restart);

export {
  CellCmp ,
  rows ,
  cols ,
  size ,
  flaggedCellsSet ,
  revealedCellsSet ,
  cellsDomMap ,
  mineField$1 as mineField,
  restart$1 as restart,
  congrats$1 as congrats,
  loh$1 as loh,
  toggleElement ,
  neighbourCells ,
  applyStyling ,
  showBombs ,
  revealCell ,
  revealCells ,
  toggleFlag ,
  createButton ,
  generateBombsMap ,
  generateBombs ,
  generateField ,
  startGame ,
  
}
/* CellCmp Not a pure module */
